<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>煮鱼空间 (最终修复版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Microsoft YaHei', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #input-video { display: none; }
        
        /* 登录弹窗 */
        #login-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white;
        }
        #login-box {
            background: #111; padding: 30px; border: 1px solid #00ffcc; border-radius: 15px;
            text-align: center; width: 80%; max-width: 300px;
        }
        input {
            background: #222; border: 1px solid #444; color: #fff; padding: 10px;
            font-size: 16px; border-radius: 5px; margin: 15px 0; text-align: center; width: 80%;
        }
        button {
            background: #00ffcc; border: none; padding: 10px 30px; color: #000;
            font-weight: bold; font-size: 16px; border-radius: 25px; cursor: pointer;
        }

        /* 调试控制台 */
        #debug-console {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 120px;
            background: rgba(0,0,0,0.8); color: #0f0; font-family: monospace; font-size: 10px;
            overflow-y: scroll; z-index: 999; padding: 10px; pointer-events: none;
            border-top: 1px solid #333; display: block;
        }
        .log-error { color: #ff3333; font-weight: bold; }
        .log-warn { color: #ffff00; }

        /* 文字特效 */
        #fan-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5);
            color: #ff69b4; font-size: 50px; font-weight: 900; z-index: 20; opacity: 0;
            transition: all 0.4s; pointer-events: none; white-space: nowrap; text-shadow: 0 0 20px #ff0055;
        }
        #fan-text.visible { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .highlight-id { color: #00ffcc; margin-right: 10px; }
    </style>
</head>
<body>

    <div id="login-modal">
        <div id="login-box">
            <h2 style="color:#00ffcc; margin:0 0 10px 0;">煮鱼空间</h2>
            <p style="font-size:12px; color:#888;">最终修复版 (JSDelivr)</p>
            <input type="text" id="username-input" maxlength="5" placeholder="输入昵称">
            <br>
            <button id="enter-btn" onclick="startExperience()">进入空间</button>
            <p id="loading-status" style="font-size:12px; color:#888; margin-top:10px;">正在连接国际节点...</p>
        </div>
    </div>

    <div id="fan-text"></div>
    <video id="input-video"></video>
    <div id="canvas-container"></div>
    <div id="debug-console">System Log Initialized...<br></div>

    <!-- 1. Three.js: 继续用 Staticfile，因为刚才证明它是好的 -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.staticfile.org/three.js/0.160.0/three.module.js"
            }
        }
    </script>
    
    <!-- 2. MediaPipe: 切换回最标准的 JSDelivr 源 -->
    <!-- 注意：去掉了 crossorigin 属性，防止跨域报错 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script type="module">
        import * as THREE from 'three';

        // 日志工具
        function log(msg, type='info') {
            const consoleDiv = document.getElementById('debug-console');
            const statusDiv = document.getElementById('loading-status');
            const line = document.createElement('div');
            line.innerHTML = `[${new Date().toLocaleTimeString()}] ${msg}`;
            if(type === 'error') {
                line.className = 'log-error';
                if(statusDiv) { statusDiv.innerText = "失败: " + msg; statusDiv.style.color = "red"; }
            } else if (type === 'warn') {
                line.className = 'log-warn';
            }
            consoleDiv.appendChild(line);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        window.onerror = function(msg) { log(`System Error: ${msg}`, 'error'); return false; };

        log("Three.js detected: " + (typeof THREE !== 'undefined'));
        log("Connecting to MediaPipe (JSDelivr)... Please wait.");

        // 延时检查机制
        let checkCount = 0;
        const checkInterval = setInterval(() => {
            checkCount++;
            if(typeof Hands !== 'undefined') {
                clearInterval(checkInterval);
                log("MediaPipe Loaded Successfully!", 'success');
                document.getElementById('loading-status').innerText = "资源加载完毕！";
                document.getElementById('loading-status').style.color = "#0f0";
            } else if (checkCount > 15) { // 等待 15秒
                clearInterval(checkInterval);
                log("连接超时。您的网络可能完全屏蔽了外部JS库。", 'error');
            } else {
                if(checkCount % 5 === 0) log("Waiting for library... (" + checkCount + "s)");
            }
        }, 1000);

        let currentUserId = "";
        let scene, camera, renderer, material, points;
        let positions, velocities, initialPositions;
        let time = 0;
        let handData = { active: false, x: 0, y: 0, gesture: 'NONE' };
        
        const CONFIG = {
            particleCount: 15000, 
            colors: {
                base: new THREE.Color(0x0088ff),
                pinch: new THREE.Color(0xff0000),
                fan: new THREE.Color(0xff69b4)
            }
        };

        window.startExperience = function() {
            const input = document.getElementById('username-input');
            const val = input.value.trim();

            if (!val) { alert("请输入昵称"); return; }
            if (typeof Hands === 'undefined') { alert("资源仍在下载中（国际线路较慢），请再等几秒钟..."); return; }

            currentUserId = val;
            document.getElementById('login-modal').style.display = 'none';
            document.getElementById('debug-console').style.opacity = '0.3';

            try {
                initThree();
                initMediaPipe();
                animate();
                log("Experience Started.");
            } catch (e) {
                log("Run Error: " + e.message, 'error');
            }
        };

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.03);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 20;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            createParticles();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(CONFIG.particleCount * 3);
            velocities = new Float32Array(CONFIG.particleCount * 3);
            initialPositions = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const r = 15 * Math.cbrt(Math.random());
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(2 * Math.random() - 1);
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;
                initialPositions[i*3] = x; initialPositions[i*3+1] = y; initialPositions[i*3+2] = z;
                colors[i*3] = CONFIG.colors.base.r; colors[i*3+1] = CONFIG.colors.base.g; colors[i*3+2] = CONFIG.colors.base.b;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            material = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 }, uSize: { value: 0.2 * window.innerHeight } },
                vertexShader: `
                    uniform float uSize; attribute vec3 color; varying vec3 vColor;
                    void main() { vColor = color; vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); gl_PointSize = uSize * (1.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; }
                `,
                fragmentShader: `
                    varying vec3 vColor; void main() { float r = distance(gl_PointCoord, vec2(0.5)); if (r > 0.5) discard; gl_FragColor = vec4(vColor, 1.0 - r * 2.0); }
                `,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
            });
            points = new THREE.Points(geometry, material);
            scene.add(points);
        }

        function updateParticles() {
            const positionsAttr = points.geometry.attributes.position;
            const colorsAttr = points.geometry.attributes.color;
            const targetX = (handData.x - 0.5) * 30;
            const targetY = -(handData.y - 0.5) * 20;
            let targetColor = CONFIG.colors.base;
            if (handData.gesture === 'PINCH') targetColor = CONFIG.colors.pinch;
            if (handData.gesture === 'OPEN') targetColor = CONFIG.colors.fan;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const ix = i * 3;
                let px = positions[ix], py = positions[ix+1], pz = positions[ix+2];
                let vx = velocities[ix], vy = velocities[ix+1], vz = velocities[ix+2];
                vx += (initialPositions[ix] - px) * 0.015; vy += (initialPositions[ix+1] - py) * 0.015; vz += (initialPositions[ix+2] - pz) * 0.015;
                if (handData.active) {
                    const dx = targetX - px, dy = targetY - py, dz = -pz;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    if (distSq < 100) {
                        const force = 50 / (distSq + 0.1);
                        if (handData.gesture === 'PINCH') { vx -= dx * force * 0.05; vy -= dy * force * 0.05; vz -= dz * force * 0.05; }
                        else if (handData.gesture === 'OPEN') { vx += (dy - dx) * 0.05; vy -= (dx + dy) * 0.05; }
                        else { vx += dx * 0.02; vy += dy * 0.02; vz += dz * 0.02; }
                    }
                }
                vx *= 0.95; vy *= 0.95; vz *= 0.95;
                positions[ix] = px + vx; positions[ix+1] = py + vy; positions[ix+2] = pz + vz;
                colorsAttr.array[ix] += (targetColor.r - colorsAttr.array[ix]) * 0.05;
                colorsAttr.array[ix+1] += (targetColor.g - colorsAttr.array[ix+1]) * 0.05;
                colorsAttr.array[ix+2] += (targetColor.b - colorsAttr.array[ix+2]) * 0.05;
            }
            positionsAttr.needsUpdate = true; colorsAttr.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            material.uniforms.uTime.value = time;
            updateParticles();
            renderer.render(scene, camera);
        }

        function initMediaPipe() {
            log("Initializing Camera...");
            const videoElement = document.getElementById('input-video');

            // 使用 JSDelivr 的标准路径
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onHandsResults);

            const camera = new Camera(videoElement, {
                onFrame: async () => await hands.send({image: videoElement}),
                width: 640, height: 480
            });
            
            camera.start().then(() => {
                log("Camera Active. Ready!");
            }).catch(e => {
                log("Camera Failed: " + e.message, 'error');
                alert("无法启动摄像头，请检查权限。");
            });
        }

        function onHandsResults(results) {
            const fanText = document.getElementById('fan-text');
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const palm = landmarks[9];
                handData.active = true; handData.x = 1.0 - palm.x; handData.y = palm.y;
                const thumbTip = landmarks[4]; const indexTip = landmarks[8];
                const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
                
                if (distance < 0.05) { 
                    handData.gesture = 'PINCH'; fanText.classList.remove('visible'); 
                } else if (distance > 0.12) {
                    handData.gesture = 'OPEN';
                    fanText.innerHTML = `<span class="highlight-id">${currentUserId}</span> 是煮鱼铁粉`;
                    fanText.classList.add('visible');
                } else { 
                    handData.gesture = 'NONE'; fanText.classList.remove('visible'); 
                }
            } else { handData.active = false; fanText.classList.remove('visible'); }
        }
    </script>
</body>
</html>
